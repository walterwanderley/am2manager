// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user.sql

package user

import (
	"context"
	"database/sql"
	"time"
)

const contUsers = `-- name: ContUsers :one
SELECT count(*) FROM user
`

// http: GET /users/count
func (q *Queries) ContUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, contUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, name, status, created_at, updated_at, picture from user WHERE email = ?
`

// http: GET /users
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Picture,
	)
	return i, err
}

const listAllFavoriteCaptures = `-- name: ListAllFavoriteCaptures :many
SELECT c.id, c.name, c.description, c.downloads, c.has_cab, c.type, c.created_at, c.demo_link, uf.user_id
FROM user_favorite uf, capture c
WHERE uf.capture_id = c.id
ORDER BY uf.created_at DESC
LIMIT ? OFFSET ?
`

type ListAllFavoriteCapturesParams struct {
	Limit  int64
	Offset int64
}

type ListAllFavoriteCapturesRow struct {
	ID          int64
	Name        string
	Description sql.NullString
	Downloads   int64
	HasCab      sql.NullBool
	Type        string
	CreatedAt   time.Time
	DemoLink    sql.NullString
	UserID      int64
}

// http: GET /favorites
func (q *Queries) ListAllFavoriteCaptures(ctx context.Context, arg ListAllFavoriteCapturesParams) ([]ListAllFavoriteCapturesRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllFavoriteCaptures, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllFavoriteCapturesRow
	for rows.Next() {
		var i ListAllFavoriteCapturesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Downloads,
			&i.HasCab,
			&i.Type,
			&i.CreatedAt,
			&i.DemoLink,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const addFavoriteCapture = `-- name: addFavoriteCapture :execresult
INSERT INTO user_favorite(user_id, capture_id) VALUES(?,?)
`

type addFavoriteCaptureParams struct {
	UserID    int64
	CaptureID int64
}

// http: POST /users/{user_id}/captures/{capture_id}
func (q *Queries) addFavoriteCapture(ctx context.Context, arg addFavoriteCaptureParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, addFavoriteCapture, arg.UserID, arg.CaptureID)
}

const addUser = `-- name: addUser :execresult
INSERT INTO user(name, email, status, picture) 
VALUES(?,?,?,?)
`

type addUserParams struct {
	Name    string
	Email   string
	Status  string
	Picture sql.NullString
}

func (q *Queries) addUser(ctx context.Context, arg addUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, addUser,
		arg.Name,
		arg.Email,
		arg.Status,
		arg.Picture,
	)
}

const getFavoriteCapture = `-- name: getFavoriteCapture :one
SELECT user_id, capture_id, created_at
FROM user_favorite
WHERE user_id = ? AND capture_id = ?
`

type getFavoriteCaptureParams struct {
	UserID    int64
	CaptureID int64
}

// http: GET /users/{user_id}/captures/{capture_id}
func (q *Queries) getFavoriteCapture(ctx context.Context, arg getFavoriteCaptureParams) (UserFavorite, error) {
	row := q.db.QueryRowContext(ctx, getFavoriteCapture, arg.UserID, arg.CaptureID)
	var i UserFavorite
	err := row.Scan(&i.UserID, &i.CaptureID, &i.CreatedAt)
	return i, err
}

const getUser = `-- name: getUser :one
SELECT id, email, name, status, created_at, updated_at, picture FROM user WHERE id = ?
`

// http: GET /users/{id}
func (q *Queries) getUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Picture,
	)
	return i, err
}

const listFavoriteCaptures = `-- name: listFavoriteCaptures :many
SELECT c.id, c.name, c.description, c.downloads, c.has_cab, c.type, c.created_at, c.demo_link
FROM user_favorite uf, capture c
WHERE uf.capture_id = c.id AND uf.user_id = ?
ORDER BY uf.created_at DESC
LIMIT ? OFFSET ?
`

type listFavoriteCapturesParams struct {
	UserID int64
	Limit  int64
	Offset int64
}

type listFavoriteCapturesRow struct {
	ID          int64
	Name        string
	Description sql.NullString
	Downloads   int64
	HasCab      sql.NullBool
	Type        string
	CreatedAt   time.Time
	DemoLink    sql.NullString
}

// http: GET /users/{user_id}/captures
func (q *Queries) listFavoriteCaptures(ctx context.Context, arg listFavoriteCapturesParams) ([]listFavoriteCapturesRow, error) {
	rows, err := q.db.QueryContext(ctx, listFavoriteCaptures, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listFavoriteCapturesRow
	for rows.Next() {
		var i listFavoriteCapturesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Downloads,
			&i.HasCab,
			&i.Type,
			&i.CreatedAt,
			&i.DemoLink,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFavoriteCapture = `-- name: removeFavoriteCapture :execresult
DELETE FROM user_favorite WHERE user_id = ? AND capture_id = ?
`

type removeFavoriteCaptureParams struct {
	UserID    int64
	CaptureID int64
}

// http: DELETE /users/{user_id}/captures/{capture_id}
func (q *Queries) removeFavoriteCapture(ctx context.Context, arg removeFavoriteCaptureParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, removeFavoriteCapture, arg.UserID, arg.CaptureID)
}

const updateUserName = `-- name: updateUserName :execresult
UPDATE user SET name = ?, updated_at = date()  WHERE id = ?
`

type updateUserNameParams struct {
	Name string
	ID   int64
}

// http: PATCH /users/{id}/name
func (q *Queries) updateUserName(ctx context.Context, arg updateUserNameParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateUserName, arg.Name, arg.ID)
}

const updateUserPicture = `-- name: updateUserPicture :execresult
UPDATE user SET picture = ?, updated_at = date()  WHERE id = ?
`

type updateUserPictureParams struct {
	Picture sql.NullString
	ID      int64
}

func (q *Queries) updateUserPicture(ctx context.Context, arg updateUserPictureParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateUserPicture, arg.Picture, arg.ID)
}
